{"ast":null,"code":"var _jsxFileName = \"/Users/devulapellykushalkumarreddy/Downloads/CHALYATI/car-rental-frontend/src/components/DotGrid.jsx\",\n  _s = $RefreshSig$();\nimport { gsap } from 'gsap';\nimport { InertiaPlugin } from 'gsap/InertiaPlugin';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport './DotGrid.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\ngsap.registerPlugin(InertiaPlugin);\nconst throttle = (func, limit) => {\n  let lastCall = 0;\n  return function (...args) {\n    const now = performance.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      func.apply(this, args);\n    }\n  };\n};\nfunction hexToRgb(hex) {\n  const m = hex.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n  if (!m) return {\n    r: 0,\n    g: 0,\n    b: 0\n  };\n  return {\n    r: parseInt(m[1], 16),\n    g: parseInt(m[2], 16),\n    b: parseInt(m[3], 16)\n  };\n}\nconst DotGrid = ({\n  dotSize = 16,\n  gap = 32,\n  baseColor = '#5227FF',\n  activeColor = '#5227FF',\n  proximity = 150,\n  speedTrigger = 100,\n  shockRadius = 250,\n  shockStrength = 5,\n  maxSpeed = 5000,\n  resistance = 750,\n  returnDuration = 1.5,\n  className = '',\n  style\n}) => {\n  _s();\n  const wrapperRef = useRef(null);\n  const canvasRef = useRef(null);\n  const dotsRef = useRef([]);\n  const pointerRef = useRef({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 0,\n    speed: 0,\n    lastTime: 0,\n    lastX: 0,\n    lastY: 0\n  });\n  const baseRgb = useMemo(() => hexToRgb(baseColor), [baseColor]);\n  const activeRgb = useMemo(() => hexToRgb(activeColor), [activeColor]);\n  const circlePath = useMemo(() => {\n    if (typeof window === 'undefined' || !window.Path2D) return null;\n    const p = new window.Path2D();\n    p.arc(0, 0, dotSize / 2, 0, Math.PI * 2);\n    return p;\n  }, [dotSize]);\n  const buildGrid = useCallback(() => {\n    const wrap = wrapperRef.current;\n    const canvas = canvasRef.current;\n    if (!wrap || !canvas) {\n      console.log('DotGrid: Missing wrap or canvas', {\n        wrap,\n        canvas\n      });\n      return;\n    }\n    const {\n      width,\n      height\n    } = wrap.getBoundingClientRect();\n    console.log('DotGrid: Building grid with dimensions', {\n      width,\n      height\n    });\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.scale(dpr, dpr);\n      // Debug: Add a subtle background to see if canvas is working\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n      ctx.fillRect(0, 0, width, height);\n    }\n    const cols = Math.floor((width + gap) / (dotSize + gap));\n    const rows = Math.floor((height + gap) / (dotSize + gap));\n    const cell = dotSize + gap;\n    const gridW = cell * cols - gap;\n    const gridH = cell * rows - gap;\n    const extraX = width - gridW;\n    const extraY = height - gridH;\n    const startX = extraX / 2 + dotSize / 2;\n    const startY = extraY / 2 + dotSize / 2;\n    const dots = [];\n    for (let y = 0; y < rows; y++) {\n      for (let x = 0; x < cols; x++) {\n        const cx = startX + x * cell;\n        const cy = startY + y * cell;\n        dots.push({\n          cx,\n          cy,\n          xOffset: 0,\n          yOffset: 0,\n          _inertiaApplied: false\n        });\n      }\n    }\n    dotsRef.current = dots;\n  }, [dotSize, gap]);\n  useEffect(() => {\n    if (!circlePath) return;\n    let rafId;\n    const proxSq = proximity * proximity;\n    const draw = () => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      const {\n        x: px,\n        y: py\n      } = pointerRef.current;\n      for (const dot of dotsRef.current) {\n        const ox = dot.cx + dot.xOffset;\n        const oy = dot.cy + dot.yOffset;\n        const dx = dot.cx - px;\n        const dy = dot.cy - py;\n        const dsq = dx * dx + dy * dy;\n        let style = baseColor;\n        if (dsq <= proxSq) {\n          const dist = Math.sqrt(dsq);\n          const t = 1 - dist / proximity;\n          const r = Math.round(baseRgb.r + (activeRgb.r - baseRgb.r) * t);\n          const g = Math.round(baseRgb.g + (activeRgb.g - baseRgb.g) * t);\n          const b = Math.round(baseRgb.b + (activeRgb.b - baseRgb.b) * t);\n          style = `rgb(${r},${g},${b})`;\n        }\n        ctx.save();\n        ctx.translate(ox, oy);\n        ctx.fillStyle = style;\n        ctx.fill(circlePath);\n        ctx.restore();\n      }\n      rafId = requestAnimationFrame(draw);\n    };\n    draw();\n    return () => cancelAnimationFrame(rafId);\n  }, [proximity, baseColor, activeRgb, baseRgb, circlePath]);\n  useEffect(() => {\n    buildGrid();\n    let ro = null;\n    if ('ResizeObserver' in window) {\n      ro = new ResizeObserver(buildGrid);\n      wrapperRef.current && ro.observe(wrapperRef.current);\n    } else {\n      window.addEventListener('resize', buildGrid);\n    }\n    return () => {\n      if (ro) ro.disconnect();else window.removeEventListener('resize', buildGrid);\n    };\n  }, [buildGrid]);\n  useEffect(() => {\n    const onMove = e => {\n      const now = performance.now();\n      const pr = pointerRef.current;\n      const dt = pr.lastTime ? now - pr.lastTime : 16;\n      const dx = e.clientX - pr.lastX;\n      const dy = e.clientY - pr.lastY;\n      let vx = dx / dt * 1000;\n      let vy = dy / dt * 1000;\n      let speed = Math.hypot(vx, vy);\n      if (speed > maxSpeed) {\n        const scale = maxSpeed / speed;\n        vx *= scale;\n        vy *= scale;\n        speed = maxSpeed;\n      }\n      pr.lastTime = now;\n      pr.lastX = e.clientX;\n      pr.lastY = e.clientY;\n      pr.vx = vx;\n      pr.vy = vy;\n      pr.speed = speed;\n      const rect = canvasRef.current.getBoundingClientRect();\n      pr.x = e.clientX - rect.left;\n      pr.y = e.clientY - rect.top;\n      for (const dot of dotsRef.current) {\n        const dist = Math.hypot(dot.cx - pr.x, dot.cy - pr.y);\n        if (speed > speedTrigger && dist < proximity && !dot._inertiaApplied) {\n          dot._inertiaApplied = true;\n          gsap.killTweensOf(dot);\n          const pushX = dot.cx - pr.x + vx * 0.005;\n          const pushY = dot.cy - pr.y + vy * 0.005;\n          gsap.to(dot, {\n            inertia: {\n              xOffset: pushX,\n              yOffset: pushY,\n              resistance\n            },\n            onComplete: () => {\n              gsap.to(dot, {\n                xOffset: 0,\n                yOffset: 0,\n                duration: returnDuration,\n                ease: 'elastic.out(1,0.75)'\n              });\n              dot._inertiaApplied = false;\n            }\n          });\n        }\n      }\n    };\n    const onClick = e => {\n      const rect = canvasRef.current.getBoundingClientRect();\n      const cx = e.clientX - rect.left;\n      const cy = e.clientY - rect.top;\n      for (const dot of dotsRef.current) {\n        const dist = Math.hypot(dot.cx - cx, dot.cy - cy);\n        if (dist < shockRadius && !dot._inertiaApplied) {\n          dot._inertiaApplied = true;\n          gsap.killTweensOf(dot);\n          const falloff = Math.max(0, 1 - dist / shockRadius);\n          const pushX = (dot.cx - cx) * shockStrength * falloff;\n          const pushY = (dot.cy - cy) * shockStrength * falloff;\n          gsap.to(dot, {\n            inertia: {\n              xOffset: pushX,\n              yOffset: pushY,\n              resistance\n            },\n            onComplete: () => {\n              gsap.to(dot, {\n                xOffset: 0,\n                yOffset: 0,\n                duration: returnDuration,\n                ease: 'elastic.out(1,0.75)'\n              });\n              dot._inertiaApplied = false;\n            }\n          });\n        }\n      }\n    };\n    const throttledMove = throttle(onMove, 50);\n    window.addEventListener('mousemove', throttledMove, {\n      passive: true\n    });\n    window.addEventListener('click', onClick);\n    return () => {\n      window.removeEventListener('mousemove', throttledMove);\n      window.removeEventListener('click', onClick);\n    };\n  }, [maxSpeed, speedTrigger, proximity, resistance, returnDuration, shockRadius, shockStrength]);\n  return /*#__PURE__*/_jsxDEV(\"section\", {\n    className: `dot-grid ${className}`,\n    style: style,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: wrapperRef,\n      className: \"dot-grid__wrap\",\n      children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"dot-grid__canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 270,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 269,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 268,\n    columnNumber: 5\n  }, this);\n};\n_s(DotGrid, \"mFjE+zUQAMVe1ll5A3lc0VjRvtk=\");\n_c = DotGrid;\nexport default DotGrid;\nvar _c;\n$RefreshReg$(_c, \"DotGrid\");","map":{"version":3,"names":["gsap","InertiaPlugin","useCallback","useEffect","useMemo","useRef","jsxDEV","_jsxDEV","registerPlugin","throttle","func","limit","lastCall","args","now","performance","apply","hexToRgb","hex","m","match","r","g","b","parseInt","DotGrid","dotSize","gap","baseColor","activeColor","proximity","speedTrigger","shockRadius","shockStrength","maxSpeed","resistance","returnDuration","className","style","_s","wrapperRef","canvasRef","dotsRef","pointerRef","x","y","vx","vy","speed","lastTime","lastX","lastY","baseRgb","activeRgb","circlePath","window","Path2D","p","arc","Math","PI","buildGrid","wrap","current","canvas","console","log","width","height","getBoundingClientRect","dpr","devicePixelRatio","ctx","getContext","scale","fillStyle","fillRect","cols","floor","rows","cell","gridW","gridH","extraX","extraY","startX","startY","dots","cx","cy","push","xOffset","yOffset","_inertiaApplied","rafId","proxSq","draw","clearRect","px","py","dot","ox","oy","dx","dy","dsq","dist","sqrt","t","round","save","translate","fill","restore","requestAnimationFrame","cancelAnimationFrame","ro","ResizeObserver","observe","addEventListener","disconnect","removeEventListener","onMove","e","pr","dt","clientX","clientY","hypot","rect","left","top","killTweensOf","pushX","pushY","to","inertia","onComplete","duration","ease","onClick","falloff","max","throttledMove","passive","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/devulapellykushalkumarreddy/Downloads/CHALYATI/car-rental-frontend/src/components/DotGrid.jsx"],"sourcesContent":["import { gsap } from 'gsap';\nimport { InertiaPlugin } from 'gsap/InertiaPlugin';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\n\nimport './DotGrid.css';\n\ngsap.registerPlugin(InertiaPlugin);\n\nconst throttle = (func, limit) => {\n  let lastCall = 0;\n  return function (...args) {\n    const now = performance.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      func.apply(this, args);\n    }\n  };\n};\n\nfunction hexToRgb(hex) {\n  const m = hex.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n  if (!m) return { r: 0, g: 0, b: 0 };\n  return {\n    r: parseInt(m[1], 16),\n    g: parseInt(m[2], 16),\n    b: parseInt(m[3], 16)\n  };\n}\n\nconst DotGrid = ({\n  dotSize = 16,\n  gap = 32,\n  baseColor = '#5227FF',\n  activeColor = '#5227FF',\n  proximity = 150,\n  speedTrigger = 100,\n  shockRadius = 250,\n  shockStrength = 5,\n  maxSpeed = 5000,\n  resistance = 750,\n  returnDuration = 1.5,\n  className = '',\n  style\n}) => {\n  const wrapperRef = useRef(null);\n  const canvasRef = useRef(null);\n  const dotsRef = useRef([]);\n  const pointerRef = useRef({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 0,\n    speed: 0,\n    lastTime: 0,\n    lastX: 0,\n    lastY: 0\n  });\n\n  const baseRgb = useMemo(() => hexToRgb(baseColor), [baseColor]);\n  const activeRgb = useMemo(() => hexToRgb(activeColor), [activeColor]);\n\n  const circlePath = useMemo(() => {\n    if (typeof window === 'undefined' || !window.Path2D) return null;\n\n    const p = new window.Path2D();\n    p.arc(0, 0, dotSize / 2, 0, Math.PI * 2);\n    return p;\n  }, [dotSize]);\n\n  const buildGrid = useCallback(() => {\n    const wrap = wrapperRef.current;\n    const canvas = canvasRef.current;\n    if (!wrap || !canvas) {\n      console.log('DotGrid: Missing wrap or canvas', { wrap, canvas });\n      return;\n    }\n\n    const { width, height } = wrap.getBoundingClientRect();\n    console.log('DotGrid: Building grid with dimensions', { width, height });\n    const dpr = window.devicePixelRatio || 1;\n\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.scale(dpr, dpr);\n      // Debug: Add a subtle background to see if canvas is working\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    const cols = Math.floor((width + gap) / (dotSize + gap));\n    const rows = Math.floor((height + gap) / (dotSize + gap));\n    const cell = dotSize + gap;\n\n    const gridW = cell * cols - gap;\n    const gridH = cell * rows - gap;\n\n    const extraX = width - gridW;\n    const extraY = height - gridH;\n\n    const startX = extraX / 2 + dotSize / 2;\n    const startY = extraY / 2 + dotSize / 2;\n\n    const dots = [];\n    for (let y = 0; y < rows; y++) {\n      for (let x = 0; x < cols; x++) {\n        const cx = startX + x * cell;\n        const cy = startY + y * cell;\n        dots.push({ cx, cy, xOffset: 0, yOffset: 0, _inertiaApplied: false });\n      }\n    }\n    dotsRef.current = dots;\n  }, [dotSize, gap]);\n\n  useEffect(() => {\n    if (!circlePath) return;\n\n    let rafId;\n    const proxSq = proximity * proximity;\n\n    const draw = () => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      const { x: px, y: py } = pointerRef.current;\n\n      for (const dot of dotsRef.current) {\n        const ox = dot.cx + dot.xOffset;\n        const oy = dot.cy + dot.yOffset;\n        const dx = dot.cx - px;\n        const dy = dot.cy - py;\n        const dsq = dx * dx + dy * dy;\n\n        let style = baseColor;\n        if (dsq <= proxSq) {\n          const dist = Math.sqrt(dsq);\n          const t = 1 - dist / proximity;\n          const r = Math.round(baseRgb.r + (activeRgb.r - baseRgb.r) * t);\n          const g = Math.round(baseRgb.g + (activeRgb.g - baseRgb.g) * t);\n          const b = Math.round(baseRgb.b + (activeRgb.b - baseRgb.b) * t);\n          style = `rgb(${r},${g},${b})`;\n        }\n\n        ctx.save();\n        ctx.translate(ox, oy);\n        ctx.fillStyle = style;\n        ctx.fill(circlePath);\n        ctx.restore();\n      }\n\n      rafId = requestAnimationFrame(draw);\n    };\n\n    draw();\n    return () => cancelAnimationFrame(rafId);\n  }, [proximity, baseColor, activeRgb, baseRgb, circlePath]);\n\n  useEffect(() => {\n    buildGrid();\n    let ro = null;\n    if ('ResizeObserver' in window) {\n      ro = new ResizeObserver(buildGrid);\n      wrapperRef.current && ro.observe(wrapperRef.current);\n    } else {\n      window.addEventListener('resize', buildGrid);\n    }\n    return () => {\n      if (ro) ro.disconnect();\n      else window.removeEventListener('resize', buildGrid);\n    };\n  }, [buildGrid]);\n\n  useEffect(() => {\n    const onMove = e => {\n      const now = performance.now();\n      const pr = pointerRef.current;\n      const dt = pr.lastTime ? now - pr.lastTime : 16;\n      const dx = e.clientX - pr.lastX;\n      const dy = e.clientY - pr.lastY;\n      let vx = (dx / dt) * 1000;\n      let vy = (dy / dt) * 1000;\n      let speed = Math.hypot(vx, vy);\n      if (speed > maxSpeed) {\n        const scale = maxSpeed / speed;\n        vx *= scale;\n        vy *= scale;\n        speed = maxSpeed;\n      }\n      pr.lastTime = now;\n      pr.lastX = e.clientX;\n      pr.lastY = e.clientY;\n      pr.vx = vx;\n      pr.vy = vy;\n      pr.speed = speed;\n\n      const rect = canvasRef.current.getBoundingClientRect();\n      pr.x = e.clientX - rect.left;\n      pr.y = e.clientY - rect.top;\n\n      for (const dot of dotsRef.current) {\n        const dist = Math.hypot(dot.cx - pr.x, dot.cy - pr.y);\n        if (speed > speedTrigger && dist < proximity && !dot._inertiaApplied) {\n          dot._inertiaApplied = true;\n          gsap.killTweensOf(dot);\n          const pushX = dot.cx - pr.x + vx * 0.005;\n          const pushY = dot.cy - pr.y + vy * 0.005;\n          gsap.to(dot, {\n            inertia: { xOffset: pushX, yOffset: pushY, resistance },\n            onComplete: () => {\n              gsap.to(dot, {\n                xOffset: 0,\n                yOffset: 0,\n                duration: returnDuration,\n                ease: 'elastic.out(1,0.75)'\n              });\n              dot._inertiaApplied = false;\n            }\n          });\n        }\n      }\n    };\n\n    const onClick = e => {\n      const rect = canvasRef.current.getBoundingClientRect();\n      const cx = e.clientX - rect.left;\n      const cy = e.clientY - rect.top;\n      for (const dot of dotsRef.current) {\n        const dist = Math.hypot(dot.cx - cx, dot.cy - cy);\n        if (dist < shockRadius && !dot._inertiaApplied) {\n          dot._inertiaApplied = true;\n          gsap.killTweensOf(dot);\n          const falloff = Math.max(0, 1 - dist / shockRadius);\n          const pushX = (dot.cx - cx) * shockStrength * falloff;\n          const pushY = (dot.cy - cy) * shockStrength * falloff;\n          gsap.to(dot, {\n            inertia: { xOffset: pushX, yOffset: pushY, resistance },\n            onComplete: () => {\n              gsap.to(dot, {\n                xOffset: 0,\n                yOffset: 0,\n                duration: returnDuration,\n                ease: 'elastic.out(1,0.75)'\n              });\n              dot._inertiaApplied = false;\n            }\n          });\n        }\n      }\n    };\n\n    const throttledMove = throttle(onMove, 50);\n    window.addEventListener('mousemove', throttledMove, { passive: true });\n    window.addEventListener('click', onClick);\n\n    return () => {\n      window.removeEventListener('mousemove', throttledMove);\n      window.removeEventListener('click', onClick);\n    };\n  }, [maxSpeed, speedTrigger, proximity, resistance, returnDuration, shockRadius, shockStrength]);\n\n  return (\n    <section className={`dot-grid ${className}`} style={style}>\n      <div ref={wrapperRef} className=\"dot-grid__wrap\">\n        <canvas ref={canvasRef} className=\"dot-grid__canvas\" />\n      </div>\n    </section>\n  );\n};\n\nexport default DotGrid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}